// Code generated by MockGen. DO NOT EDIT.
// Source: ../internal/core/application/repository/tracing_repository.go
//
// Generated by this command:
//
//	mockgen -source=../internal/core/application/repository/tracing_repository.go -destination=../test/mock/mock_tracing_repository.go -package=mock
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	applicationrepository "github.com/duducv/go-clean-arch/internal/core/application/repository"
	gomock "go.uber.org/mock/gomock"
)

// MockTracingRepository is a mock of TracingRepository interface.
type MockTracingRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTracingRepositoryMockRecorder
}

// MockTracingRepositoryMockRecorder is the mock recorder for MockTracingRepository.
type MockTracingRepositoryMockRecorder struct {
	mock *MockTracingRepository
}

// NewMockTracingRepository creates a new mock instance.
func NewMockTracingRepository(ctrl *gomock.Controller) *MockTracingRepository {
	mock := &MockTracingRepository{ctrl: ctrl}
	mock.recorder = &MockTracingRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTracingRepository) EXPECT() *MockTracingRepositoryMockRecorder {
	return m.recorder
}

// CaptureError mocks base method.
func (m *MockTracingRepository) CaptureError(ctx context.Context, err error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CaptureError", ctx, err)
}

// CaptureError indicates an expected call of CaptureError.
func (mr *MockTracingRepositoryMockRecorder) CaptureError(ctx, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CaptureError", reflect.TypeOf((*MockTracingRepository)(nil).CaptureError), ctx, err)
}

// StartSpan mocks base method.
func (m *MockTracingRepository) StartSpan(ctx context.Context, spanName, spanType string) (applicationrepository.Span, context.Context) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartSpan", ctx, spanName, spanType)
	ret0, _ := ret[0].(applicationrepository.Span)
	ret1, _ := ret[1].(context.Context)
	return ret0, ret1
}

// StartSpan indicates an expected call of StartSpan.
func (mr *MockTracingRepositoryMockRecorder) StartSpan(ctx, spanName, spanType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartSpan", reflect.TypeOf((*MockTracingRepository)(nil).StartSpan), ctx, spanName, spanType)
}

// MockSpan is a mock of Span interface.
type MockSpan struct {
	ctrl     *gomock.Controller
	recorder *MockSpanMockRecorder
}

// MockSpanMockRecorder is the mock recorder for MockSpan.
type MockSpanMockRecorder struct {
	mock *MockSpan
}

// NewMockSpan creates a new mock instance.
func NewMockSpan(ctrl *gomock.Controller) *MockSpan {
	mock := &MockSpan{ctrl: ctrl}
	mock.recorder = &MockSpanMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSpan) EXPECT() *MockSpanMockRecorder {
	return m.recorder
}

// End mocks base method.
func (m *MockSpan) End() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "End")
}

// End indicates an expected call of End.
func (mr *MockSpanMockRecorder) End() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "End", reflect.TypeOf((*MockSpan)(nil).End))
}
